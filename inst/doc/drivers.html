<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Rich FitzJohn" />

<meta name="date" content="2016-01-20" />

<title>storr drivers</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0A%7D%0Apre%20%7B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">storr drivers</h1>
<h4 class="author"><em>Rich FitzJohn</em></h4>
<h4 class="date"><em>2016-01-20</em></h4>
</div>


<p>Requirements for storr drivers.</p>
<p>The idea here is that you implement a handful of methods and the package will construct a common interface around them. There are built-in tests in the package to ensure that the driver behaves correctly, and infrastructure to help with running those tests.</p>
<p>To demonstrate we’ll write a wrapper around RSQLite to store data.</p>
<div id="how-it-works-and-what-we-need" class="section level1">
<h1>How it works and what we need</h1>
<p>The required methods are:</p>
<p>Given a driver <code>dr</code>, storr retrieves values (<code>get</code>) by running:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_hash</span>(key, namespace)
hash &lt;-<span class="st"> </span>dr$<span class="kw">get_hash</span>(key, namespace)
dr$<span class="kw">exists_object</span>(hash)
dr$<span class="kw">get_object</span>(hash)</code></pre></div>
<p>which:</p>
<ol style="list-style-type: decimal">
<li>checks that a key exists (keys being defined by a combination of key and namespace)</li>
<li>retrieves the object hash stored against that key</li>
<li>checks that the hash is actually present in the database</li>
<li>retrieves the object stored against the hash</li>
</ol>
<p>hashes are stored as strings, while objects are <em>serialised R objects</em>, usually stored in binary. The driver is responsible for serialisation/deserialisation as that will depend on the properties of the driver.</p>
<p>storr will take care of throwing appropriate errors if the object is not found (which requires the calls to <code>exists_hash</code> and <code>exists_object</code>).</p>
<p><code>set</code> works in a similar way:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hash &lt;-<span class="st"> </span>storr:::<span class="kw">hash_object</span>(hash)
if (!dr$<span class="kw">exists_object</span>(hash)) {
  dr$<span class="kw">set_object</span>(hash, value)
}
dr$<span class="kw">set_hash</span>(key, namespace, hash)</code></pre></div>
<p>The important part here is that storr will avoid setting the object if it can be avoided (i.e., if the hash is present in the database then the object has already been stored – because saving the actual data is likely to be the slowest part it’s worth avoiding).</p>
<ol style="list-style-type: decimal">
<li>if the hash is not present, save the (serialised) object against the hash.</li>
<li>store the hash against the key and namespace.</li>
</ol>
<p>The total list of required functions is:</p>
<p>(see TODO.md)</p>
<div id="a-digression-keyvalue-stores-and-sql" class="section level2">
<h2>A digression: key/value stores and SQL</h2>
<p>SQL data bases are probably not going to be a great place to store key/value data (especially very large objects) and this section is not meant to be normative. Instead, this is one possible route that could be taken. Recent version of postgresql include interfaces that support first class key/value (<code>hstore</code>) which would be prefereable to this.</p>
<p>Details from <a href="http://jfaganuk.github.io/2015/01/12/storing-r-objects-in-sqlite-tables/">here</a></p>
<p>Start with a SQLite connection (similar things can be done with other DBI drivers but at present this uses one SQLite-only function below):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">con &lt;-<span class="st"> </span>DBI::<span class="kw">dbConnect</span>(RSQLite::<span class="kw">SQLite</span>(), <span class="st">&quot;:memory:&quot;</span>)</code></pre></div>
<p>This will create a table into which we can put key/value pairs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table &lt;-<span class="st"> &quot;mydata&quot;</span>
sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;CREATE TABLE IF NOT EXISTS %s&quot;</span>, table),
         <span class="st">&quot;(name string PRIMARY KEY,&quot;</span>,
         <span class="st">&quot;value blob)&quot;</span>)
DBI::<span class="kw">dbGetQuery</span>(con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))</code></pre></div>
<p>Then take an object, serialise it, and stuff it into the blob:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">value &lt;-<span class="st"> </span>mtcars
name &lt;-<span class="st"> &quot;mtcars&quot;</span>

dat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">name=</span>name,
                  <span class="dt">value=</span><span class="kw">I</span>(<span class="kw">list</span>(<span class="kw">serialize</span>(value, <span class="ot">NULL</span>))),
                  <span class="dt">stringsAsFactors=</span><span class="ot">FALSE</span>)
sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;INSERT into %s (name, value) values (:name, :value)&quot;</span>, table)
RSQLite::<span class="kw">dbGetPreparedQuery</span>(con, sql, <span class="dt">bind.data=</span>dat)</code></pre></div>
<p>The complicated bit here is using the <code>RSQLite::dbGetPreparedQuery</code> to inject the raw byte sequence of the serialised object into the <code>value</code> column (note that this is not a <code>DBI</code> function, otherwise . I believe that similar approaches are possible in other DBI drivers. With the new development version of DBI/RSQLite this will change to using <code>DBI::dbBind</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DBI::<span class="kw">dbGetQuery</span>(con, sql, <span class="dt">bind.data=</span>dat)</code></pre></div>
<p>which is great because it means that the driver below would work for other DBI-compliant backends (development versions of RPostgres and RMySQL at least).</p>
<p>We can retrieve the data by name:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT value FROM %s WHERE name == &quot;%s&quot;'</span>, table, name)
x &lt;-<span class="st"> </span><span class="kw">unserialize</span>(DBI::<span class="kw">dbGetQuery</span>(con, sql)[[<span class="dv">1</span>]][[<span class="dv">1</span>]])
<span class="kw">identical</span>(x, value)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="implementing-the-storr-driver" class="section level2">
<h2>Implementing the storr driver</h2>
<p>For consistency with other <code>storr</code> functions, even though the driver is an R6 object, we construct it using a plain R function (not the <code>$new()</code> method of an R6 generator. This is because the driver <em>could</em> be implemented as a function that generates a list of closures or a reference class.</p>
<p>There are quite a few required functions to implement. Below, the value in parentheses after the function signature is the expected return type.</p>
<ul>
<li><code>type()</code> (character): Takes no argument and returns a string with the “type” of the driver. This can be any identifier.</li>
<li><p><code>destroy()</code> (NULL): Takes no argument and destroys all data associated with the driver. Best to also leave the driver in a state where it can’t be used, though this is not enforced.</p></li>
<li><code>set_hash(key, namespace, hash)</code> (NULL): Given strings for <code>key</code>, <code>namespace</code> and <code>hash</code> against the key/namespace pair.</li>
<li><p><code>get_hash(key, namespace)</code> (character): Given strings for <code>key</code>, and <code>namespace</code>, return the hash of the object.</p></li>
<li><code>set_object(hash, value)</code> (NULL): Given a string <code>hash</code> and an arbitrary object <code>value</code>, store the object against the hash. Serialisation will likely be needed here (e.g., <code>serialize(value,   NULL)</code>).</li>
<li><p><code>get_object(hash)</code> (object): Given a string <code>hash</code> return the R object stored against it. Deserialisation will likely be needed here (e.g., <code>unserialize(dat)</code>)</p></li>
<li><code>exists_hash(key, namespace)</code> (logical): Given strings for <code>key</code> and <code>namespace</code> return <code>TRUE</code> if there is a hash stored against the key/namespace pair, <code>FALSE</code> otherwise.</li>
<li><p><code>exists_object(hash)</code> (logical): Given a string for <code>hash</code>, return <code>TRUE</code> if there is an object stored against the hash.</p></li>
<li><code>del_hash(key, namespace)</code> (logical): Given strings for <code>key</code> and <code>namespace</code>, delete this key if it exists. Return <code>TRUE</code> if the key existed, <code>FALSE</code> otherwise.</li>
<li><p><code>del_object(hash)</code> (logical): Given a string for <code>hash</code> the object if it exists. Return <code>TRUE</code> if the hash existed, <code>FALSE</code> otherwise.</p></li>
<li><code>list_hashes()</code> (character vector): Return a character vector of all known hashes.</li>
<li><code>list_namespaces()</code> (character vector): Return a character vector of all known namespaces.</li>
<li><p><code>list_keys(namespace)</code> (character vector): Given a string <code>namespace</code>, return a character vector of all known keys within the namespace.</p></li>
</ul>
<p>The arguments to the constructor will be</p>
<ul>
<li><code>path</code>: Path to the SQLite database</li>
<li><code>tbl_data</code>: Name of the table to store the data (hash/object pairs) in.</li>
<li><code>tbl_keys</code>: Name of the table to store the keys (key/namespace/hash triplets) in.</li>
</ul>
<p>The SQL queries are a bit ugly but hopefully straightforward enough to follow.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">driver_sqlite &lt;-<span class="st"> </span>function(path, <span class="dt">tbl_data=</span><span class="st">&quot;storr_data&quot;</span>, <span class="dt">tbl_keys=</span><span class="st">&quot;storr_keys&quot;</span>) {
  .R6_driver_sqlite$<span class="kw">new</span>(path, tbl_data, tbl_keys)
}</code></pre></div>
<p>The R6 class definition that implements the functions above, with a little commentry throughout.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.R6_driver_sqlite &lt;-<span class="st"> </span>R6::<span class="kw">R6Class</span>(
  <span class="st">&quot;driver_sqlite&quot;</span>,
  <span class="dt">public=</span><span class="kw">list</span>(
    ## Public data members
    <span class="dt">con=</span><span class="ot">NULL</span>,
    <span class="dt">tbl_data=</span><span class="ot">NULL</span>,
    <span class="dt">tbl_keys=</span><span class="ot">NULL</span>,

    ## On initialisation we'll create the two tables but only if they
    ## do not exist.  We can enforce the constraint that hash must be
    ## unique within tbl_data and key/`namespace pairs must be unique
    ## within tbl_keys.
    <span class="dt">initialize=</span>function(path, tbl_data, tbl_keys) {
      self$con &lt;-<span class="st"> </span>DBI::<span class="kw">dbConnect</span>(RSQLite::<span class="kw">SQLite</span>(), path)
      self$tbl_data &lt;-<span class="st"> </span>tbl_data
      self$tbl_keys &lt;-<span class="st"> </span>tbl_keys

      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;CREATE TABLE if NOT EXISTS %s&quot;</span>, tbl_data),
               <span class="st">&quot;(hash string PRIMARY KEY NOT NULL,&quot;</span>,
               <span class="st">&quot;value blob NOT NULL)&quot;</span>)
      DBI::<span class="kw">dbGetQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))

      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;CREATE TABLE IF NOT EXISTS %s&quot;</span>, tbl_keys),
               <span class="st">&quot;(namespace string NOT NULL,&quot;</span>,
               <span class="st">&quot;key string NOT NULL,&quot;</span>,
               <span class="st">&quot;hash string NOT NULL,&quot;</span>,
               <span class="st">&quot;PRIMARY KEY (namespace, key))&quot;</span>)
      DBI::<span class="kw">dbGetQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))
    },

    ## This is purely for identification later.
    <span class="dt">type=</span>function() {
      <span class="st">&quot;DBI/sqlite&quot;</span>
    },

    ## Total destruction of the driver; delete all data stored in both
    ## tables, then delete our database connection to render the
    ## driver useless.
    <span class="dt">destroy=</span>function() {
      DBI::<span class="kw">dbRemoveTable</span>(self$con, self$tbl_data)
      DBI::<span class="kw">dbRemoveTable</span>(self$con, self$tbl_keys)
      self$con &lt;-<span class="st"> </span><span class="ot">NULL</span>
    },

    ## Return the hash value given a key/namespace pair
    <span class="dt">get_hash=</span>function(key, namespace) {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT hash FROM &quot;%s&quot; WHERE namespace=&quot;%s&quot; AND key=&quot;%s&quot;'</span>,
                     self$tbl_keys, namespace, key)
      DBI::<span class="kw">dbGetQuery</span>(self$con, sql)[[<span class="dv">1</span>]]
    },
    ## Set the key/namespace pair to a hash
    <span class="dt">set_hash=</span>function(key, namespace, hash) {
      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;INSERT OR REPLACE INTO %s&quot;</span>, self$tbl_keys),
               <span class="kw">sprintf</span>(<span class="st">'(namespace, key, hash) VALUES (&quot;%s&quot;, &quot;%s&quot;, &quot;%s&quot;)'</span>,
                       namespace, key, hash))
      DBI::<span class="kw">dbGetQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))
    },

    ## Return a (deserialised) R object, given a hash
    <span class="dt">get_object=</span>function(hash) {
      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;SELECT value FROM %s&quot;</span>, self$tbl_data),
               <span class="kw">sprintf</span>(<span class="st">'WHERE hash = &quot;%s&quot;'</span>, hash))
      value &lt;-<span class="st"> </span>DBI::<span class="kw">dbGetQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))[[<span class="dv">1</span>]]
      <span class="kw">unserialize</span>(value[[<span class="dv">1</span>]])
    },

    ## Set a (serialised) R object against a hash.  This would be
    ## considerably simpler (but probably slower and less accurate) if we
    ## serialised to string with:
    ##   rawToChar(serialize(value, NULL, TRUE))
    <span class="dt">set_object=</span>function(hash, value) {
      dat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">hash=</span>hash,
                        <span class="dt">value=</span><span class="kw">I</span>(<span class="kw">list</span>(<span class="kw">serialize</span>(value, <span class="ot">NULL</span>))),
                        <span class="dt">stringsAsFactors=</span><span class="ot">FALSE</span>)
      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;INSERT OR REPLACE INTO %s&quot;</span>, self$tbl_data),
               <span class="st">&quot;(hash, value) VALUES (:hash, :value)&quot;</span>)
      RSQLite::<span class="kw">dbGetPreparedQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>),
                                  <span class="dt">bind.data=</span>dat)
    },

    ## Check if a key/namespace pair exists.
    <span class="dt">exists_hash=</span>function(key, namespace) {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT 1 FROM %s WHERE namespace = &quot;%s&quot; AND key = &quot;%s&quot;'</span>,
                     self$tbl_keys, namespace, key)
      <span class="kw">nrow</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)) &gt;<span class="st"> </span>0L
    },
    ## Check if a hash exists
    <span class="dt">exists_object=</span>function(hash) {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT 1 FROM %s WHERE hash = &quot;%s&quot;'</span>,
                     self$tbl_data, hash)
      <span class="kw">nrow</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)) &gt;<span class="st"> </span>0L
    },

    ## Delete a key.  Because of the requirement to return TRUE/FALSE on
    ## successful/unsuccessful key deletion this includes an exists_hash()
    ## step first.
    <span class="dt">del_hash=</span>function(key, namespace) {
      if (self$<span class="kw">exists_hash</span>(key, namespace)) {
        sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'DELETE FROM %s WHERE namespace = &quot;%s&quot; AND key = &quot;%s&quot;'</span>,
                       self$tbl_keys, namespace, key)
        DBI::<span class="kw">dbGetQuery</span>(self$con, sql)
        <span class="ot">TRUE</span>
      } else {
        <span class="ot">FALSE</span>
      }
    },
    ## Delete a hash
    <span class="dt">del_object=</span>function(hash) {
      if (self$<span class="kw">exists_object</span>(hash)) {
        sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'DELETE FROM %s WHERE hash = &quot;%s&quot;'</span>, self$tbl_data, hash)
        DBI::<span class="kw">dbGetQuery</span>(self$con, sql)
        <span class="ot">TRUE</span>
      } else {
        <span class="ot">FALSE</span>
      }
    },

    ## List hashes, namespaces and keys.  Because the SQLite driver seems to
    ## return numeric(0) if the result set is empty, we need as.character here.
    <span class="dt">list_hashes=</span>function() {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;SELECT hash FROM %s&quot;</span>, self$tbl_data)
      <span class="kw">as.character</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)[[<span class="dv">1</span>]])
    },
    <span class="dt">list_namespaces=</span>function() {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;SELECT DISTINCT namespace FROM %s&quot;</span>, self$tbl_keys)
      <span class="kw">as.character</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)[[<span class="dv">1</span>]])
    },
    <span class="dt">list_keys=</span>function(namespace) {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT key FROM %s WHERE namespace=&quot;%s&quot;'</span>,
                     self$tbl_keys, namespace)
      <span class="kw">as.character</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)[[<span class="dv">1</span>]])
    }
  ))</code></pre></div>
<p>Next, let’s give the driver a little workout.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr &lt;-<span class="st"> </span><span class="kw">driver_sqlite</span>(<span class="st">&quot;:memory:&quot;</span>)</code></pre></div>
<p>Start with the hash part of the database. At first we have no hashes in the database:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>so <code>exists_object</code> returns <code>FALSE</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hash &lt;-<span class="st"> </span>digest::<span class="kw">digest</span>(mtcars)
dr$<span class="kw">exists_object</span>(hash)</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>We can set an object against a hash:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">set_object</span>(hash, mtcars)</code></pre></div>
<p>and then <code>exists_object</code> will return <code>TRUE</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_object</span>(hash)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>and we can retrieve the object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(dr$<span class="kw">get_object</span>(hash))</code></pre></div>
<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<p>Our set of hashes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## [1] &quot;a63c70e73b58d0823ab3bcbd3b543d6f&quot;</code></pre>
<p>Delete the hash:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">del_object</span>(hash)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>And it’s gone:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_object</span>(hash)</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Set up a key</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">key &lt;-<span class="st"> &quot;aaa&quot;</span>
namespace &lt;-<span class="st"> &quot;ns&quot;</span>
dr$<span class="kw">set_hash</span>(key, namespace, hash)</code></pre></div>
<p>Which now exists:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_hash</span>(key, namespace)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>And can be listed:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_keys</span>(namespace)</code></pre></div>
<pre><code>## [1] &quot;aaa&quot;</code></pre>
<p>and the hash against the key returned:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">get_hash</span>(key, namespace)</code></pre></div>
<pre><code>## [1] &quot;a63c70e73b58d0823ab3bcbd3b543d6f&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">del_hash</span>(key, namespace)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_hash</span>(key, namespace)</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_keys</span>(namespace)</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>OK, so this <em>seems</em> to be working. But how do we test if it is actually working? <code>storr</code> provides an automatic testing facility based on <code>testthat</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">storr::<span class="kw">test_driver</span>(function() <span class="kw">driver_sqlite</span>(<span class="st">&quot;:memory:&quot;</span>))</code></pre></div>
<pre><code>## drivers [DBI/sqlite] : ..................................
## export [DBI/sqlite] : ..........................................
## external [DBI/sqlite] : .................
## storr [DBI/sqlite] : ...................................................</code></pre>
<pre><code>## PASS: 0 errors, 0 failures / 144 tests total</code></pre>
<pre><code>## 
## DONE</code></pre>
<p>The argument a function that generates a database that we are allowed to write anything to and then destroy when complete. So <code>:memory:</code> is a good path here!</p>
<p>Now that the driver works, we can write the wrapper function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">storr_sqlite &lt;-<span class="st"> </span>function(path,
                         <span class="dt">tbl_data=</span><span class="st">&quot;storr_data&quot;</span>, <span class="dt">tbl_keys=</span><span class="st">&quot;storr_keys&quot;</span>,
                         <span class="dt">default_namespace=</span><span class="st">&quot;objects&quot;</span>) {
  storr::<span class="kw">storr</span>(<span class="kw">driver_sqlite</span>(path, tbl_data, tbl_keys),
               default_namespace)
}</code></pre></div>
<p>and construct a <code>storr</code> with it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql &lt;-<span class="st"> </span><span class="kw">storr_sqlite</span>(<span class="st">&quot;:memory:&quot;</span>)</code></pre></div>
<p>Nothing in the storr:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">list</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>Set some data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">set</span>(<span class="st">&quot;foo&quot;</span>, <span class="kw">runif</span>(<span class="dv">10</span>))</code></pre></div>
<p>Retrieve it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">get</span>(<span class="st">&quot;foo&quot;</span>)</code></pre></div>
<pre><code>##  [1] 0.04484327 0.45731706 0.75433034 0.37579498 0.23034976 0.54217720
##  [7] 0.69080673 0.69813017 0.30629113 0.57083091</code></pre>
<p>Delete it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">del</span>(<span class="st">&quot;foo&quot;</span>)
st_sql$<span class="kw">list</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>Underlying data is still kicking around:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## [1] &quot;d710066515611cbb489c3ca4beb50322&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">get_value</span>(st_sql$<span class="kw">list_hashes</span>())</code></pre></div>
<pre><code>##  [1] 0.04484327 0.45731706 0.75433034 0.37579498 0.23034976 0.54217720
##  [7] 0.69080673 0.69813017 0.30629113 0.57083091</code></pre>
<p>But we can garbage collect:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">gc</span>()
st_sql$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>As implemented (totally naively) above, this driver is quite a bit slower than the rds driver (which is ~= the same speed as the redis driver)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_rds &lt;-<span class="st"> </span>storr::<span class="kw">storr_rds</span>(<span class="kw">tempfile</span>())
microbenchmark::<span class="kw">microbenchmark</span>(
  st_sql$<span class="kw">set</span>(key, <span class="kw">runif</span>(<span class="dv">10</span>), <span class="dt">use_cache=</span><span class="ot">FALSE</span>),
  st_rds$<span class="kw">set</span>(key, <span class="kw">runif</span>(<span class="dv">10</span>), <span class="dt">use_cache=</span><span class="ot">FALSE</span>))</code></pre></div>
<pre><code>## Unit: microseconds
##                                           expr      min       lq     mean
##  st_sql$set(key, runif(10), use_cache = FALSE) 1426.756 1608.726 1834.836
##  st_rds$set(key, runif(10), use_cache = FALSE)  437.336  585.568 1191.773
##    median        uq      max neval
##  1833.503 1986.3725  2802.40   100
##   638.896  724.6605 50568.94   100</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">microbenchmark::<span class="kw">microbenchmark</span>(
  st_sql$<span class="kw">get</span>(key, <span class="dt">use_cache=</span><span class="ot">FALSE</span>),
  st_rds$<span class="kw">get</span>(key, <span class="dt">use_cache=</span><span class="ot">FALSE</span>))</code></pre></div>
<pre><code>## Unit: microseconds
##                                expr      min       lq      mean   median
##  st_sql$get(key, use_cache = FALSE) 1594.188 1659.052 1793.4794 1699.562
##  st_rds$get(key, use_cache = FALSE)  136.356  157.400  214.6712  205.290
##         uq      max neval
##  1756.6560 3417.217   100
##   234.1555 1675.544   100</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">destroy</span>()
st_rds$<span class="kw">destroy</span>()</code></pre></div>
<p>This is not really SQL’s strong suit. But if key/value storage is a small part of an application that already uses SQLite for storage then this approach could be a sensible move.</p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
