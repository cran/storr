<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Rich FitzJohn" />

<meta name="date" content="2016-12-05" />

<title>storr drivers</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">storr drivers</h1>
<h4 class="author"><em>Rich FitzJohn</em></h4>
<h4 class="date"><em>2016-12-05</em></h4>



<p>Requirements for storr drivers.</p>
<p>The idea here is that you implement a handful of methods and the package will construct a common interface around them. There are built-in tests in the package to ensure that the driver behaves correctly, and infrastructure to help with running those tests.</p>
<p>To demonstrate we’ll write a wrapper around RSQLite to store data.</p>
<div id="how-it-works-and-what-we-need" class="section level1">
<h1>How it works and what we need</h1>
<p>First, consider the <code>get</code> method in storr. With a driver <code>dr</code>, storr retrieves values by running:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_hash</span>(key, namespace)
hash &lt;-<span class="st"> </span>dr$<span class="kw">get_hash</span>(key, namespace)
dr$<span class="kw">exists_object</span>(hash)
dr$<span class="kw">get_object</span>(hash)</code></pre></div>
<p>which:</p>
<ol style="list-style-type: decimal">
<li>checks that a key exists (keys being defined by a combination of key and namespace)</li>
<li>retrieves the object hash stored against that key</li>
<li>checks that the hash is actually present in the database</li>
<li>retrieves the object stored against the hash</li>
</ol>
<p>hashes are stored as strings, while objects are <em>serialised R objects</em>, usually stored in binary. The driver is responsible for serialisation/deserialisation as that will depend on the properties of the driver.</p>
<p>storr will take care of throwing appropriate errors if the object is not found (which requires the calls to <code>exists_hash</code> and <code>exists_object</code>).</p>
<p><code>set</code> works in a similar way:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hash &lt;-<span class="st"> </span>storr:::<span class="kw">hash_object</span>(hash)
if (!dr$<span class="kw">exists_object</span>(hash)) {
  dr$<span class="kw">set_object</span>(hash, value)
}
dr$<span class="kw">set_hash</span>(key, namespace, hash)</code></pre></div>
<p>The important part here is that storr will avoid setting the object if it can be avoided (i.e., if the hash is present in the database then the object has already been stored – because saving the actual data is likely to be the slowest part it’s worth avoiding).</p>
<ol style="list-style-type: decimal">
<li>if the hash is not present, save the (serialised) object against the hash.</li>
<li>store the hash against the key and namespace.</li>
</ol>
<p>The full list of functions needed follows the next section.</p>
<div id="a-digression-keyvalue-stores-and-sql" class="section level2">
<h2>A digression: key/value stores and SQL</h2>
<p>SQL databases are probably not going to be a great place to store key/value data (especially very large objects) and this section is not meant to be normative. Instead, this is one possible route that could be taken. Recent version of postgresql include interfaces that support first class key/value (<code>hstore</code>) which would be prefereable to this.</p>
<p>The details come from <a href="http://jfaganuk.github.io/2015/01/12/storing-r-objects-in-sqlite-tables/">here</a>, but this is likely to change with the new work coming soon (see below).</p>
<p>Start with a SQLite connection (similar things can be done with other DBI drivers but at present this uses one SQLite-only function below):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">con &lt;-<span class="st"> </span>DBI::<span class="kw">dbConnect</span>(RSQLite::<span class="kw">SQLite</span>(), <span class="st">&quot;:memory:&quot;</span>)</code></pre></div>
<p>This will create a table into which we can put key/value pairs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table &lt;-<span class="st"> &quot;mydata&quot;</span>
sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;CREATE TABLE IF NOT EXISTS %s&quot;</span>, table),
         <span class="st">&quot;(name string PRIMARY KEY,&quot;</span>,
         <span class="st">&quot;value blob)&quot;</span>)
DBI::<span class="kw">dbGetQuery</span>(con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))</code></pre></div>
<pre><code>## data frame with 0 columns and 0 rows</code></pre>
<p>Then take an object, serialise it, and stuff it into the blob:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">value &lt;-<span class="st"> </span>mtcars
name &lt;-<span class="st"> &quot;mtcars&quot;</span>

dat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">name=</span>name,
                  <span class="dt">value=</span><span class="kw">I</span>(<span class="kw">list</span>(<span class="kw">serialize</span>(value, <span class="ot">NULL</span>))),
                  <span class="dt">stringsAsFactors=</span><span class="ot">FALSE</span>)
sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;INSERT into %s (name, value) values (:name, :value)&quot;</span>, table)
RSQLite::<span class="kw">dbGetPreparedQuery</span>(con, sql, <span class="dt">bind.data=</span>dat)</code></pre></div>
<pre><code>## Warning: RSQLite::dbGetPreparedQuery() is deprecated, please switch to
## DBI::dbGetQuery(params = bind.data).</code></pre>
<pre><code>## data frame with 0 columns and 0 rows</code></pre>
<p>The complicated bit here is using the <code>RSQLite::dbGetPreparedQuery</code> to inject the raw byte sequence of the serialised object into the <code>value</code> column (note that this is not a <code>DBI</code> function). I believe that similar approaches are possible in other DBI drivers. With the new development version of DBI/RSQLite this will change to using <code>DBI::dbBind</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DBI::<span class="kw">dbGetQuery</span>(con, sql, <span class="dt">bind.data=</span>dat)</code></pre></div>
<p>which is great because it means that the driver below would work for other DBI-compliant backends (development versions of RPostgres and RMySQL at least).</p>
<p>We can retrieve the data by name:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT value FROM %s WHERE name == &quot;%s&quot;'</span>, table, name)
x &lt;-<span class="st"> </span><span class="kw">unserialize</span>(DBI::<span class="kw">dbGetQuery</span>(con, sql)[[<span class="dv">1</span>]][[<span class="dv">1</span>]])
<span class="kw">identical</span>(x, value)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="implementing-the-storr-driver" class="section level2">
<h2>Implementing the storr driver</h2>
<p>For consistency with other <code>storr</code> functions, even though the driver is an R6 object, we construct it using a plain R function (not the <code>$new()</code> method of an R6 generator. This is because the driver <em>could</em> be implemented as a function that generates a list of closures or a reference class.</p>
<p>There are quite a few required functions to implement. Below, the value in parentheses after the function signature is the expected return type.</p>
<ul>
<li><code>type()</code> (returns character): Takes no argument and returns a string with the “type” of the driver. This can be any identifier.</li>
<li><p><code>destroy()</code> (returns NULL): Takes no argument and destroys all data associated with the driver. Best to also leave the driver in a state where it can’t be used, though this is not enforced.</p></li>
<li><code>set_hash(key, namespace, hash)</code> (returns NULL): Given strings for <code>key</code>, <code>namespace</code> and <code>hash</code>, set the <code>hash</code> against the <code>key</code>/<code>namespace</code> pair.</li>
<li><p><code>get_hash(key, namespace)</code> (returns character): Given strings for <code>key</code>, and <code>namespace</code>, return the hash of the object.</p></li>
<li><code>set_object(hash, value)</code> (returns NULL): Given a string <code>hash</code> and an arbitrary object <code>value</code>, store the object against the hash. Serialisation will likely be needed here (e.g., <code>serialize(value, NULL)</code>).</li>
<li><p><code>get_object(hash)</code> (returns object): Given a string <code>hash</code> return the R object stored against it. Deserialisation will likely be needed here (e.g., <code>unserialize(dat)</code>)</p></li>
<li><code>exists_hash(key, namespace)</code> (returns logical): Given strings for <code>key</code> and <code>namespace</code> return <code>TRUE</code> if there is a hash stored against the key/namespace pair, <code>FALSE</code> otherwise.</li>
<li><p><code>exists_object(hash)</code> (returns logical): Given a string for <code>hash</code>, return <code>TRUE</code> if there is an object stored against the hash.</p></li>
<li><code>del_hash(key, namespace)</code> (returns logical): Given strings for <code>key</code> and <code>namespace</code>, delete this key if it exists. Return <code>TRUE</code> if the key existed, <code>FALSE</code> otherwise.</li>
<li><p><code>del_object(hash)</code> (returns logical): Given a string for <code>hash</code> the object if it exists. Return <code>TRUE</code> if the hash existed, <code>FALSE</code> otherwise.</p></li>
<li><p><code>list_hashes()</code> (returns character vector): Return a character vector of all known hashes.</p></li>
<li><code>list_namespaces()</code> (returns character vector): Return a character vector of all known namespaces.</li>
<li><p><code>list_keys(namespace)</code> (returns character vector): Given a string <code>namespace</code>, return a character vector of all known keys within the namespace.</p></li>
</ul>
<p>The arguments to the constructor will be</p>
<ul>
<li><code>path</code>: Path to the SQLite database</li>
<li><code>tbl_data</code>: Name of the table to store the data (hash/object pairs) in.</li>
<li><code>tbl_keys</code>: Name of the table to store the keys (key/namespace/hash triplets) in.</li>
</ul>
<p>The SQL queries are a bit ugly but hopefully straightforward enough to follow.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">driver_sqlite &lt;-<span class="st"> </span>function(path, <span class="dt">tbl_data=</span><span class="st">&quot;storr_data&quot;</span>, <span class="dt">tbl_keys=</span><span class="st">&quot;storr_keys&quot;</span>) {
  .R6_driver_sqlite$<span class="kw">new</span>(path, tbl_data, tbl_keys)
}</code></pre></div>
<p>The R6 class definition that implements the functions above, with a little commentry throughout.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.R6_driver_sqlite &lt;-<span class="st"> </span>R6::<span class="kw">R6Class</span>(
  <span class="st">&quot;driver_sqlite&quot;</span>,
  <span class="dt">public=</span><span class="kw">list</span>(
    ## Public data members
    <span class="dt">con=</span><span class="ot">NULL</span>,
    <span class="dt">tbl_data=</span><span class="ot">NULL</span>,
    <span class="dt">tbl_keys=</span><span class="ot">NULL</span>,

    ## On initialisation we'll create the two tables but only if they
    ## do not exist.  We can enforce the constraint that hash must be
    ## unique within tbl_data and key/namespace pairs must be unique
    ## within tbl_keys.
    <span class="dt">initialize=</span>function(path, tbl_data, tbl_keys) {
      self$con &lt;-<span class="st"> </span>DBI::<span class="kw">dbConnect</span>(RSQLite::<span class="kw">SQLite</span>(), path)
      self$tbl_data &lt;-<span class="st"> </span>tbl_data
      self$tbl_keys &lt;-<span class="st"> </span>tbl_keys

      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;CREATE TABLE if NOT EXISTS %s&quot;</span>, tbl_data),
               <span class="st">&quot;(hash string PRIMARY KEY NOT NULL,&quot;</span>,
               <span class="st">&quot;value blob NOT NULL)&quot;</span>)
      DBI::<span class="kw">dbGetQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))

      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;CREATE TABLE IF NOT EXISTS %s&quot;</span>, tbl_keys),
               <span class="st">&quot;(namespace string NOT NULL,&quot;</span>,
               <span class="st">&quot;key string NOT NULL,&quot;</span>,
               <span class="st">&quot;hash string NOT NULL,&quot;</span>,
               <span class="st">&quot;PRIMARY KEY (namespace, key))&quot;</span>)
      DBI::<span class="kw">dbGetQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))
    },

    ## This is purely for identification later.
    <span class="dt">type=</span>function() {
      <span class="st">&quot;DBI/sqlite&quot;</span>
    },

    ## Total destruction of the driver; delete all data stored in both
    ## tables, then delete our database connection to render the
    ## driver useless.
    <span class="dt">destroy=</span>function() {
      DBI::<span class="kw">dbRemoveTable</span>(self$con, self$tbl_data)
      DBI::<span class="kw">dbRemoveTable</span>(self$con, self$tbl_keys)
      self$con &lt;-<span class="st"> </span><span class="ot">NULL</span>
    },

    ## Return the hash value given a key/namespace pair
    <span class="dt">get_hash=</span>function(key, namespace) {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT hash FROM &quot;%s&quot; WHERE namespace=&quot;%s&quot; AND key=&quot;%s&quot;'</span>,
                     self$tbl_keys, namespace, key)
      DBI::<span class="kw">dbGetQuery</span>(self$con, sql)[[<span class="dv">1</span>]]
    },
    ## Set the key/namespace pair to a hash
    <span class="dt">set_hash=</span>function(key, namespace, hash) {
      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;INSERT OR REPLACE INTO %s&quot;</span>, self$tbl_keys),
               <span class="kw">sprintf</span>(<span class="st">'(namespace, key, hash) VALUES (&quot;%s&quot;, &quot;%s&quot;, &quot;%s&quot;)'</span>,
                       namespace, key, hash))
      DBI::<span class="kw">dbGetQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))
    },

    ## Return a (deserialised) R object, given a hash
    <span class="dt">get_object=</span>function(hash) {
      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;SELECT value FROM %s&quot;</span>, self$tbl_data),
               <span class="kw">sprintf</span>(<span class="st">'WHERE hash = &quot;%s&quot;'</span>, hash))
      value &lt;-<span class="st"> </span>DBI::<span class="kw">dbGetQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>))[[<span class="dv">1</span>]]
      <span class="kw">unserialize</span>(value[[<span class="dv">1</span>]])
    },

    ## Set a (serialised) R object against a hash.  This would be
    ## considerably simpler (but probably slower and less accurate) if we
    ## serialised to string with:
    ##   rawToChar(serialize(value, NULL, TRUE))
    <span class="dt">set_object=</span>function(hash, value) {
      dat &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">hash=</span>hash,
                        <span class="dt">value=</span><span class="kw">I</span>(<span class="kw">list</span>(<span class="kw">serialize</span>(value, <span class="ot">NULL</span>))),
                        <span class="dt">stringsAsFactors=</span><span class="ot">FALSE</span>)
      sql &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">&quot;INSERT OR REPLACE INTO %s&quot;</span>, self$tbl_data),
               <span class="st">&quot;(hash, value) VALUES (:hash, :value)&quot;</span>)
      RSQLite::<span class="kw">dbGetPreparedQuery</span>(self$con, <span class="kw">paste</span>(sql, <span class="dt">collapse=</span><span class="st">&quot; &quot;</span>),
                                  <span class="dt">bind.data=</span>dat)
    },

    ## Check if a key/namespace pair exists.
    <span class="dt">exists_hash=</span>function(key, namespace) {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT 1 FROM %s WHERE namespace = &quot;%s&quot; AND key = &quot;%s&quot;'</span>,
                     self$tbl_keys, namespace, key)
      <span class="kw">nrow</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)) &gt;<span class="st"> </span>0L
    },
    ## Check if a hash exists
    <span class="dt">exists_object=</span>function(hash) {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT 1 FROM %s WHERE hash = &quot;%s&quot;'</span>,
                     self$tbl_data, hash)
      <span class="kw">nrow</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)) &gt;<span class="st"> </span>0L
    },

    ## Delete a key.  Because of the requirement to return TRUE/FALSE on
    ## successful/unsuccessful key deletion this includes an exists_hash()
    ## step first.
    <span class="dt">del_hash=</span>function(key, namespace) {
      if (self$<span class="kw">exists_hash</span>(key, namespace)) {
        sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'DELETE FROM %s WHERE namespace = &quot;%s&quot; AND key = &quot;%s&quot;'</span>,
                       self$tbl_keys, namespace, key)
        DBI::<span class="kw">dbGetQuery</span>(self$con, sql)
        <span class="ot">TRUE</span>
      } else {
        <span class="ot">FALSE</span>
      }
    },
    ## Delete a hash
    <span class="dt">del_object=</span>function(hash) {
      if (self$<span class="kw">exists_object</span>(hash)) {
        sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'DELETE FROM %s WHERE hash = &quot;%s&quot;'</span>, self$tbl_data, hash)
        DBI::<span class="kw">dbGetQuery</span>(self$con, sql)
        <span class="ot">TRUE</span>
      } else {
        <span class="ot">FALSE</span>
      }
    },

    ## List hashes, namespaces and keys.  Because the SQLite driver seems to
    ## return numeric(0) if the result set is empty, we need as.character here.
    <span class="dt">list_hashes=</span>function() {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;SELECT hash FROM %s&quot;</span>, self$tbl_data)
      <span class="kw">as.character</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)[[<span class="dv">1</span>]])
    },
    <span class="dt">list_namespaces=</span>function() {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">&quot;SELECT DISTINCT namespace FROM %s&quot;</span>, self$tbl_keys)
      <span class="kw">as.character</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)[[<span class="dv">1</span>]])
    },
    <span class="dt">list_keys=</span>function(namespace) {
      sql &lt;-<span class="st"> </span><span class="kw">sprintf</span>(<span class="st">'SELECT key FROM %s WHERE namespace=&quot;%s&quot;'</span>,
                     self$tbl_keys, namespace)
      <span class="kw">as.character</span>(DBI::<span class="kw">dbGetQuery</span>(self$con, sql)[[<span class="dv">1</span>]])
    }
  ))</code></pre></div>
<p>Next, let’s give the driver a little workout.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr &lt;-<span class="st"> </span><span class="kw">driver_sqlite</span>(<span class="st">&quot;:memory:&quot;</span>)</code></pre></div>
<p>Start with the hash part of the database. At first we have no hashes in the database:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>so <code>exists_object</code> returns <code>FALSE</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hash &lt;-<span class="st"> </span>digest::<span class="kw">digest</span>(mtcars)
dr$<span class="kw">exists_object</span>(hash)</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>We can set an object against a hash:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">set_object</span>(hash, mtcars)</code></pre></div>
<pre><code>## data frame with 0 columns and 0 rows</code></pre>
<p>and then <code>exists_object</code> will return <code>TRUE</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_object</span>(hash)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>and we can retrieve the object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(dr$<span class="kw">get_object</span>(hash))</code></pre></div>
<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<p>Our set of hashes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## [1] &quot;a63c70e73b58d0823ab3bcbd3b543d6f&quot;</code></pre>
<p>Delete the hash:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">del_object</span>(hash)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>And it’s gone:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_object</span>(hash)</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>Set up a key</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">key &lt;-<span class="st"> &quot;aaa&quot;</span>
namespace &lt;-<span class="st"> &quot;ns&quot;</span>
dr$<span class="kw">set_hash</span>(key, namespace, hash)</code></pre></div>
<pre><code>## data frame with 0 columns and 0 rows</code></pre>
<p>Which now exists:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_hash</span>(key, namespace)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>And can be listed:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_keys</span>(namespace)</code></pre></div>
<pre><code>## [1] &quot;aaa&quot;</code></pre>
<p>and the hash against the key returned:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">get_hash</span>(key, namespace)</code></pre></div>
<pre><code>## [1] &quot;a63c70e73b58d0823ab3bcbd3b543d6f&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">del_hash</span>(key, namespace)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">exists_hash</span>(key, namespace)</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dr$<span class="kw">list_keys</span>(namespace)</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>OK, so this <em>seems</em> to be working. But how do we test if it is actually working? <code>storr</code> provides an automatic testing facility based on <code>testthat</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">storr::<span class="kw">test_driver</span>(function() <span class="kw">driver_sqlite</span>(<span class="st">&quot;:memory:&quot;</span>))</code></pre></div>
<pre><code>## drivers [DBI/sqlite]: ..................................
## export [DBI/sqlite]: ..........................................
## external [DBI/sqlite]: .................
## storr [DBI/sqlite]: ...................................................</code></pre>
<pre><code>## PASS: 0 errors, 0 failures / 144 tests total</code></pre>
<pre><code>## 
## DONE ======================================================================</code></pre>
<p>The argument a function that generates a database that we are allowed to write anything to and then destroy when complete. So <code>:memory:</code> is a good path here!</p>
<p>Now that the driver works, we can write the wrapper function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">storr_sqlite &lt;-<span class="st"> </span>function(path,
                         <span class="dt">tbl_data=</span><span class="st">&quot;storr_data&quot;</span>, <span class="dt">tbl_keys=</span><span class="st">&quot;storr_keys&quot;</span>,
                         <span class="dt">default_namespace=</span><span class="st">&quot;objects&quot;</span>) {
  storr::<span class="kw">storr</span>(<span class="kw">driver_sqlite</span>(path, tbl_data, tbl_keys),
               default_namespace)
}</code></pre></div>
<p>and construct a <code>storr</code> with it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql &lt;-<span class="st"> </span><span class="kw">storr_sqlite</span>(<span class="st">&quot;:memory:&quot;</span>)</code></pre></div>
<p>Nothing in the storr:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">list</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>Set some data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">set</span>(<span class="st">&quot;foo&quot;</span>, <span class="kw">runif</span>(<span class="dv">10</span>))</code></pre></div>
<p>Retrieve it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">get</span>(<span class="st">&quot;foo&quot;</span>)</code></pre></div>
<pre><code>##  [1] 0.07735682 0.09499255 0.32503349 0.71169799 0.26404053 0.28034877
##  [7] 0.96978831 0.93574610 0.90757205 0.12881447</code></pre>
<p>Delete it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">del</span>(<span class="st">&quot;foo&quot;</span>)
st_sql$<span class="kw">list</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>Underlying data is still kicking around:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## [1] &quot;b624875fafc245f14591b54eb41cfcfd&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">get_value</span>(st_sql$<span class="kw">list_hashes</span>())</code></pre></div>
<pre><code>##  [1] 0.07735682 0.09499255 0.32503349 0.71169799 0.26404053 0.28034877
##  [7] 0.96978831 0.93574610 0.90757205 0.12881447</code></pre>
<p>But we can garbage collect:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">gc</span>()
st_sql$<span class="kw">list_hashes</span>()</code></pre></div>
<pre><code>## character(0)</code></pre>
<p>As implemented (totally naively) above, this driver is quite a bit slower than the rds driver (which is ~= the same speed as the redis driver)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_rds &lt;-<span class="st"> </span>storr::<span class="kw">storr_rds</span>(<span class="kw">tempfile</span>())
microbenchmark::<span class="kw">microbenchmark</span>(
  st_sql$<span class="kw">set</span>(key, <span class="kw">runif</span>(<span class="dv">10</span>), <span class="dt">use_cache=</span><span class="ot">FALSE</span>),
  st_rds$<span class="kw">set</span>(key, <span class="kw">runif</span>(<span class="dv">10</span>), <span class="dt">use_cache=</span><span class="ot">FALSE</span>))</code></pre></div>
<pre><code>## Unit: microseconds
##                                           expr      min       lq      mean
##  st_sql$set(key, runif(10), use_cache = FALSE) 1311.397 1353.208 1407.0158
##  st_rds$set(key, runif(10), use_cache = FALSE)  242.733  249.362  278.8965
##    median       uq      max neval cld
##  1380.320 1410.185 2582.162   100   b
##   254.865  268.751 1800.262   100  a</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">microbenchmark::<span class="kw">microbenchmark</span>(
  st_sql$<span class="kw">get</span>(key, <span class="dt">use_cache=</span><span class="ot">FALSE</span>),
  st_rds$<span class="kw">get</span>(key, <span class="dt">use_cache=</span><span class="ot">FALSE</span>))</code></pre></div>
<pre><code>## Unit: microseconds
##                                expr      min        lq      mean    median
##  st_sql$get(key, use_cache = FALSE) 1318.378 1346.8765 1398.5992 1369.4145
##  st_rds$get(key, use_cache = FALSE)  114.365  122.9755  139.0872  136.8665
##         uq      max neval cld
##  1401.9765 3037.834   100   b
##   150.3585  249.757   100  a</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">st_sql$<span class="kw">destroy</span>()
st_rds$<span class="kw">destroy</span>()</code></pre></div>
<p>This is not really SQL’s strong suit. But if key/value storage is a small part of an application that already uses SQLite for storage then this approach could be a sensible move.</p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
